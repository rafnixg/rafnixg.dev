{"componentChunkName":"component---src-templates-author-js","path":"/author/rafnix/","result":{"data":{"ghostAuthor":{"slug":"rafnix","name":"Rafnix Guzmán","bio":null,"cover_image":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","location":null,"website":null,"twitter":null,"facebook":null},"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__5f330dd9c6b819e6351398d9","title":"Actualiza tu perfil de GitHub con README y GitHub Actions - Parte 3","slug":"actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-3","featured":true,"feature_image":"https://images.unsplash.com/photo-1590595906931-81f04f0ccebb?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ","excerpt":"En este tercer y ultimo post crearemos nuestro propio Github Actions para automatizar la generación de nuestro archivo README","custom_excerpt":"En este tercer y ultimo post crearemos nuestro propio Github Actions para automatizar la generación de nuestro archivo README","visibility":"public","created_at_pretty":"02 August, 2020","published_at_pretty":"09 August, 2020","updated_at_pretty":"09 August, 2020","created_at":"2020-08-02T18:38:05.000-05:00","published_at":"2020-08-08T19:59:16.000-05:00","updated_at":"2020-08-08T20:01:22.000-05:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Rafnix Guzmán","slug":"rafnix","bio":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Rafnix Guzmán","slug":"rafnix","bio":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"github","slug":"github","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"github","slug":"github","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"github actions","slug":"github-actions","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"python","slug":"python","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Si aun no has leído las otras dos partes te invito a que las revises:\n\n * Crear nuestro README en GitHub\n   [/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-1/]\n * Escribir un script en python para crear nuestro README dinámico\n   [/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-2/]\n\nEn esta tercera entrega vamos a automatizar mediante GitHub Actions la\ngeneración de nuestro archivo README.md ejecutando de forma programada nuestro\nscript de Python que creamos en la publicación anterior.\n\nGitHub Actions es una funcionalidad de GitHub que nos permite automatizar flujos\nde desarrollo directamente en nuestro repositorio de código, lo que nos da la\nventaja de poder crear nuestros propios flujos y trabajos a ejecutar.\n\nAl estar integrado con nuestro repositorio de código, tenemos la ventaja de\npoder crear nuestros flujos de trabajo de CI/CD, en esta publicación no\nprofundizaremos en este tipo de implementaciones, pero si haremos uso de GitGub\nActions para ejecutar nuestro propio flujo que consiste en ejecutar un script de\nPython y realizar un PUSH a nuestro repositorio de datos cuando exista un cambio\nen el archivo README.md.\n\nCreando nuestro primer GitHub Actions\nPara poder activar esta funcionalidad solo debemos crear un directorio en la\nraíz de nuestro proyecto llamado .github dentro de este directorio creamos otro\ndirectorio llamado workflows.\n\n$ mkdir .github\n$ cd .github\n$ mkdir workflows\n\n\nYa con esto podemos comenzara crear nuestro workflow usando un archivo YAML,\npara este caso mi archivo se va a llamar python-app.yml\n[https://github.com/rafnixg/rafnixg/blob/master/.github/workflows/python-app.yml] \npero puede tener el nombre que ustedes quieran.\n\nSi hacemos un push al repositorio y revisamos el tab de \"Actions\" veremos\nnuestro workflow y estará en un estado de falla ya que aun no hemos agregado\nningún trabajo ni los pasos a seguir.\n\n# Raíz del proyecto\n$ git add .github/workflows/python-app.yml\n$ git commit -m \"[ADD] new workflow for GitHub Actions\"\n$ git push origin master\n\n\nGitHub Actions tabPara editar nuestro archivo lo haremos directamente desde\nGitHub para aprovechar el auto completado y otras herramientas que tiene GitHub\npara la creación de Actions, al abrir nuestro archivo escribimos lo siguiente:\n\nEditor de GitHubAcá podemos ver del lado derecho un panel que nos puede ayudar a\nbuscar Actions creadas por la comunidad y también nos muestra la documentación\nde GitHub Actions.\n\nname: Python workflow  #  Nombre del workflow\non:  #  llave que indica que se realizara una acción sobre algun evento \n  schedule:  # El evento que ejecutara la acción\n    - cron: \"0 */6 * * *\"  # configuración del intervalo de ejecución\n\n\nPudimos haber hecho que esta acción se ejecutara con otros eventos como un push\no un pull request, pero de esto hablare en una siguiente publicación, para\nprofundizar les recomiendo estas dos lecturas:\n\nWorkflow syntax for GitHub Actions - GitHub DocsA workflow is a configurable\nautomated process made up of one or more jobs. You must create a YAML file to\ndefine your workflow configuration.GitHub Docs\n[https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#onschedule]\nEvents that trigger workflows - GitHub DocsYou can configure your workflows to\nrun when specific activity on GitHub happens, at a scheduled time, or when an\nevent outside of GitHub occurs.GitHub Docs\n[https://docs.github.com/en/actions/reference/events-that-trigger-workflows#scheduled-events]\nHasta este momento solo hemos indicado, el nombre de nuestro workflow y que sera\nuna acción que se ejecutara de forma programada cada 6 horas, pero aun no hemos\ndefinido el job y la secuencia de pasos que se van a ejecutar, para esto debemos\neditar nuestro archivo y nos debe quedar de la siguiente manera:\n\nname: Python workflow  #  Nombre del workflow\non:  #  llave que indica que se realizara una acción sobre algun evento \n  schedule:  # El evento que ejecutara la acción\n    - cron: \"0 */6 * * *\"  # configuración del intervalo de ejecución\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v2\n      - name: Set up Python 3.8\n        uses: actions/setup-python@v2\n        with:\n          python-version: 3.8\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n      - name: Run script\n        run: |\n          python app.py\n          git config user.name rafnixg\n          git config user.email rafnixg@gmail.com\n          git add README.md\n          git diff --quiet && git diff --staged --quiet || git commit -m \"[BOT] Update README with latest info\"\n          git push origin master\n\nhttps://github.com/rafnixg/rafnixg/blob/master/.github/workflows/python-app.yml\nAl guardar los cambios en nuestro archivo tenemos ya definido un job de nombre \nbuild con el key run-on donde indicamos que el sistema operativo que va a correr\nes un ubuntu-latest, si han trabajado con este tipo de archivos YAML en docker,\nse les hará fácil comprender este archivo, sino no hay problema acá explico que\nhace nuestro archivo.\n\nDespués de la definición del jobs tenemos que definir los steps, que son esos\npasos que va a seguir nuestro job, aqui usamos dos actions que están disponibles\nen el marketplace, esta creo es una de las cosas mas interesantes de GitHub\nActions, ya que podemos crear actions y compartirlas con la comunidad para que\notras personas las puedan implementar, yo estaré usando en esta oportunidad\n\"action/checkout@v2\" que nos ayuda a configurar git en nuestro workspace y poder\ntener acceso desde el Workflow que estamos definiendo hacia nuestro repositorio\ny \"action/setup-python@v2\" que nos ayuda a configurar python en el workspace\npara poder correr nuestro script.\n\nLo siguiente sera actualizar pip e instalar las dependencias de nuestro script y\nejecutar nuestro script, ya en este punto tenemos nuestro archivo READM.md\nactualizado en nuestro workspace, solo nos resta crear un commit con este cambio\ny hacer push a nuestro repositorio.\n\nCon este push ya tenemos nuestro README.md actualizado en nuestro repositorio,\nahora cada 6 horas va a correr este Workflow en donde definimos un jobs que se\nencarga de correr nuestro script y hacer un commit cuando exista un cambio en el\narchivo README.md\n\nEn próximas publicaciones hablara un poco mas sobre las GitHubs Actions y de\ncomo crear nuestras propias actions y publicarlas para que puedan ser\nreutilizadas, si te gusto el contenido espero tu comentario.\n\nSígueme en twitter @rafnixg [https://twitter.com/rafnixg]\n\nReferencias\nFeatures • GitHub ActionsEasily build, package, release, update, and deploy\nyour\nproject in any language—on GitHub or any external system—without having to run\ncode yourself.GitHub [https://github.com/features/actions]GitHub Actions\nDocumentation - GitHub DocsAutomate, customize, and execute your software\ndevelopment workflows right in your repository with GitHub Actions. You can\ndiscover, create, and share actions to perform any job you’d like, including\nCI/CD, and combine actions in a completely customized workflow.GitHub Docs\n[https://docs.github.com/en/actions]Using Python with GitHub Actions - GitHub\nDocsYou can create a continuous integration (CI) workflow to build and test\nyour\nPython project.GitHub Docs\n[https://docs.github.com/en/actions/language-and-framework-guides/using-python-with-github-actions#requirements-file]","html":"<p>Si aun no has leído las otras dos partes te invito a que las revises:</p><ul><li><a href=\"http://localhost:2368/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-1/\">Crear nuestro README en GitHub</a></li><li><a href=\"http://localhost:2368/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-2/\">Escribir un script en python para crear nuestro README dinámico</a></li></ul><p>En esta tercera entrega vamos a automatizar mediante GitHub Actions la generación de nuestro archivo README.md ejecutando de forma programada nuestro script de Python que creamos en la publicación anterior.</p><p>GitHub Actions es una funcionalidad de GitHub que nos permite automatizar flujos de desarrollo directamente en nuestro repositorio de código, lo que nos da la ventaja de poder crear nuestros propios flujos y trabajos a ejecutar.</p><p>Al estar integrado con nuestro repositorio de código, tenemos la ventaja de poder crear nuestros flujos de trabajo de CI/CD, en esta publicación no profundizaremos en este tipo de implementaciones, pero si haremos uso de GitGub Actions para ejecutar nuestro propio flujo que consiste en ejecutar un script de Python y realizar un <strong>PUSH</strong> a nuestro repositorio de datos cuando exista un cambio en el archivo README.md.</p><h2 id=\"creando-nuestro-primer-github-actions\">Creando nuestro primer GitHub Actions</h2><p>Para poder activar esta funcionalidad solo debemos crear un directorio en la raíz de nuestro proyecto llamado <em>.github</em> dentro de este directorio creamos otro directorio llamado <em><strong>workflows</strong>.</em></p><pre><code class=\"language-bash\">$ mkdir .github\n$ cd .github\n$ mkdir workflows\n</code></pre><p>Ya con esto podemos comenzara crear nuestro <strong>workflow</strong> usando un archivo YAML, para este caso mi archivo se va a llamar <em><a href=\"https://github.com/rafnixg/rafnixg/blob/master/.github/workflows/python-app.yml\">python-app.yml</a></em> pero puede tener el nombre que ustedes quieran.</p><p>Si hacemos un push al repositorio y revisamos el tab de \"Actions\" veremos nuestro <strong>workflow</strong> y estará en un estado de falla ya que aun no hemos agregado ningún trabajo ni los pasos a seguir.</p><pre><code class=\"language-bash\"># Raíz del proyecto\n$ git add .github/workflows/python-app.yml\n$ git commit -m \"[ADD] new workflow for GitHub Actions\"\n$ git push origin master\n</code></pre><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://localhost:2368/content/images/2020/08/image.png\" class=\"kg-image\" alt srcset=\"http://localhost:2368/content/images/size/w600/2020/08/image.png 600w, http://localhost:2368/content/images/size/w1000/2020/08/image.png 1000w, http://localhost:2368/content/images/2020/08/image.png 1265w\" sizes=\"(min-width: 720px) 720px\"><figcaption>GitHub Actions tab</figcaption></figure><p>Para editar nuestro archivo lo haremos directamente desde GitHub para aprovechar el auto completado y otras herramientas que tiene GitHub para la creación de Actions, al abrir nuestro archivo escribimos lo siguiente:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://localhost:2368/content/images/2020/08/image-3.png\" class=\"kg-image\" alt srcset=\"http://localhost:2368/content/images/size/w600/2020/08/image-3.png 600w, http://localhost:2368/content/images/size/w1000/2020/08/image-3.png 1000w, http://localhost:2368/content/images/2020/08/image-3.png 1350w\" sizes=\"(min-width: 720px) 720px\"><figcaption>Editor de GitHub</figcaption></figure><p>Acá podemos ver del lado derecho un panel que nos puede ayudar a buscar Actions creadas por la comunidad y también nos muestra la documentación de GitHub Actions.</p><pre><code class=\"language-yaml\">name: Python workflow  #  Nombre del workflow\non:  #  llave que indica que se realizara una acción sobre algun evento \n  schedule:  # El evento que ejecutara la acción\n    - cron: \"0 */6 * * *\"  # configuración del intervalo de ejecución\n</code></pre><p>Pudimos haber hecho que esta acción se ejecutara con otros eventos como un push o un pull request, pero de esto hablare en una siguiente publicación, para profundizar les recomiendo estas dos lecturas:</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#onschedule\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Workflow syntax for GitHub Actions - GitHub Docs</div><div class=\"kg-bookmark-description\">A workflow is a configurable automated process made up of one or more jobs. You must create a YAML file to define your workflow configuration.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://docs.github.com/assets/images/site/favicon.ico\"><span class=\"kg-bookmark-publisher\">GitHub Docs</span></div></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://docs.github.com/en/actions/reference/events-that-trigger-workflows#scheduled-events\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Events that trigger workflows - GitHub Docs</div><div class=\"kg-bookmark-description\">You can configure your workflows to run when specific activity on GitHub happens, at a scheduled time, or when an event outside of GitHub occurs.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://docs.github.com/assets/images/site/favicon.ico\"><span class=\"kg-bookmark-publisher\">GitHub Docs</span></div></div></a></figure><p>Hasta este momento solo hemos indicado, el nombre de nuestro <strong>workflow</strong> y que sera una acción que se ejecutara de forma programada cada 6 horas, pero aun no hemos definido el <strong>job</strong> y la secuencia de pasos que se van a ejecutar, para esto debemos editar nuestro archivo y nos debe quedar de la siguiente manera:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-yaml\">name: Python workflow  #  Nombre del workflow\non:  #  llave que indica que se realizara una acción sobre algun evento \n  schedule:  # El evento que ejecutara la acción\n    - cron: \"0 */6 * * *\"  # configuración del intervalo de ejecución\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v2\n      - name: Set up Python 3.8\n        uses: actions/setup-python@v2\n        with:\n          python-version: 3.8\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n      - name: Run script\n        run: |\n          python app.py\n          git config user.name rafnixg\n          git config user.email rafnixg@gmail.com\n          git add README.md\n          git diff --quiet &amp;&amp; git diff --staged --quiet || git commit -m \"[BOT] Update README with latest info\"\n          git push origin master</code></pre><figcaption>https://github.com/rafnixg/rafnixg/blob/master/.github/workflows/python-app.yml</figcaption></figure><p>Al guardar los cambios en nuestro archivo tenemos ya definido un <strong>job</strong> de nombre <strong><em>build</em></strong><em> </em>con el key <strong><em>run-on</em></strong><em> </em>donde indicamos que el sistema operativo que va a correr es un ubuntu-latest, si han trabajado con este tipo de archivos YAML en docker, se les hará fácil comprender este archivo, sino no hay problema acá explico que hace nuestro archivo.</p><p>Después de la definición del jobs tenemos que definir los <strong>steps,</strong> que son esos pasos que va a seguir nuestro job, aqui usamos dos actions que están disponibles en el marketplace, esta creo es una de las cosas mas interesantes de GitHub Actions, ya que podemos crear actions y compartirlas con la comunidad para que otras personas las puedan implementar, yo estaré usando en esta oportunidad \"action/checkout@v2\" que nos ayuda a configurar git en nuestro <strong>workspace</strong> y poder tener acceso desde el <strong>Workflow</strong> que estamos definiendo hacia nuestro repositorio y \"action/setup-python@v2\" que nos ayuda a configurar python en el workspace para poder correr nuestro script.</p><p>Lo siguiente sera actualizar pip e instalar las dependencias de nuestro script y ejecutar nuestro script, ya en este punto tenemos nuestro archivo READM.md actualizado en nuestro <strong>workspace</strong>, solo nos resta crear un commit con este cambio y hacer push a nuestro repositorio.</p><p>Con este push ya tenemos nuestro README.md actualizado en nuestro repositorio, ahora cada 6 horas va a correr este Workflow en donde definimos un jobs que se encarga de correr nuestro script y hacer un commit cuando exista un cambio en el archivo README.md</p><p>En próximas publicaciones hablara un poco mas sobre las GitHubs Actions y de como crear nuestras propias actions y publicarlas para que puedan ser reutilizadas, si te gusto el contenido espero tu comentario.</p><p>Sígueme en twitter <a href=\"https://twitter.com/rafnixg\">@rafnixg</a></p><h2 id=\"referencias\">Referencias</h2><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://github.com/features/actions\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Features • GitHub Actions</div><div class=\"kg-bookmark-description\">Easily build, package, release, update, and deploy your project in any language—on GitHub or any external system—without having to run code yourself.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://github.githubassets.com/favicons/favicon.svg\"><span class=\"kg-bookmark-publisher\">GitHub</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://github.githubassets.com/images/modules/site/social-cards/actions.png\"></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://docs.github.com/en/actions\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">GitHub Actions Documentation - GitHub Docs</div><div class=\"kg-bookmark-description\">Automate, customize, and execute your software development workflows right in your repository with GitHub Actions. You can discover, create, and share actions to perform any job you’d like, including CI/CD, and combine actions in a completely customized workflow.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://docs.github.com/assets/images/site/favicon.ico\"><span class=\"kg-bookmark-publisher\">GitHub Docs</span></div></div></a></figure><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://docs.github.com/en/actions/language-and-framework-guides/using-python-with-github-actions#requirements-file\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Using Python with GitHub Actions - GitHub Docs</div><div class=\"kg-bookmark-description\">You can create a continuous integration (CI) workflow to build and test your Python project.</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://docs.github.com/assets/images/site/favicon.ico\"><span class=\"kg-bookmark-publisher\">GitHub Docs</span></div></div></a></figure>","url":"http://localhost:2368/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-3/","canonical_url":null,"uuid":"4bdac536-735c-4918-b598-dbcdcc1732c2","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f274e5d514f905c523ba875","reading_time":5}},{"node":{"id":"Ghost__Post__5f330dd9c6b819e6351398d8","title":"Actualiza tu perfil de GitHub con README y GitHub Actions - Parte 2","slug":"actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-2","featured":true,"feature_image":"https://images.unsplash.com/photo-1590595906931-81f04f0ccebb?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ","excerpt":"En esta segunda parte, empezaremos a darle un poco de dinamismo a nuestro archivo README, para esto haremos uso de Python y 3 librerías que nos ayudaran a hacer este proceso mas sencillo.","custom_excerpt":"En esta segunda parte, empezaremos a darle un poco de dinamismo a nuestro archivo README, para esto haremos uso de Python y 3 librerías que nos ayudaran a hacer este proceso mas sencillo.","visibility":"public","created_at_pretty":"28 July, 2020","published_at_pretty":"29 July, 2020","updated_at_pretty":"09 August, 2020","created_at":"2020-07-28T14:17:13.000-05:00","published_at":"2020-07-29T14:24:33.000-05:00","updated_at":"2020-08-08T20:06:35.000-05:00","meta_title":null,"meta_description":"En esta segunda parte, empezaremos a darle un poco de dinamismo a nuestro archivo README, para esto haremos uso de Python 3","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Rafnix Guzmán","slug":"rafnix","bio":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Rafnix Guzmán","slug":"rafnix","bio":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"python","slug":"python","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"python","slug":"python","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"git","slug":"git","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"\n\nLa idea principal es poder generar un archivo README.md con una lista de los\núltimos 5 post de este Blog, pero en esencia este código con muy poco o hasta\nnula modificacion en algunos casos puede servir para otros servicios como dev.to\n[https://dev.to/], Medium [https://medium.com/] o WordPress.\n\nYa teniendo nuestro archivo README.md creado en el post Actualiza tu perfil de\nGitHub con README y Github Actions - Parte 1\n[/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-1/] , nos\nubicamos en la carpeta de nuestro proyecto y empezaremos creamos una copia de\nnuestro archivo pero con extensión .template, quedándonos algo como esto:\nREADME.md.template, este sera el archivo que usaremos como base para generar\nnuestro README.md\n\nLuego editamos la sección de \"Latest post (Spanish)\" sustituyendo nuestros post\nestáticos con este código en Jinja2, que nos ayuda a iterar sobre una lista de\npost.\n\n## Latest Posts (Spanish)\n\n{% for post in latest_post %}\n- [{{post.title}}]({{post.link}})\n{%  endfor %}\n\n\n\nEn esta plantilla indico que le voy a pasar latest_post y que debo recorrer sus\npost e imprimirlos dentro de un link en markdown.\n\nAhora necesitamos el endpoint a el que consultaremos para obtener nuestras lista\nde posts, para esto haré uso de las RSS [https://es.wikipedia.org/wiki/RSS] que\ntiene Ghost y con el siguiente servicio lo convertiré de XML a JSON\n\nRss to json online converter - rss2json.comFree online API to convert RSS to\nJSONrss2json [https://rss2json.com]Acá pudimos haberlo hecho de muchas maneras\ndistintas, se pudo haber usado la API ded Ghost y hacer la petición directa o se\npudo haber hecho el cambio de XML a JSON usando Python, mi idea era hacerlo lo\nmas simple posible, si tienes una idea mejor la espero en los comentarios o un\nPull Request, ya con esto aclarado podemos continuar xD.\n\nTeniendo nuestro endpoint listo procederemos a crear nuestro script en Python,\npor lo que primero debemos preparar, es nuestro entorno virtual que nos ayude a\naislar nuestras dependencias para este proyecto, podemos hacer uso de Pipenv del\ncual tengo un tutorial por acá (Entornos virtuales en python usando Pipenv\n[/entornos-virtuales-en-python-usando-pipenv/]), pero en este caso lo haremos de\nla siguiente manera ya que es la mas comun.\n\n$ python3 -m venv env\n$ source env/bin/activate\n$ touch app.py\n\n\nLo que creara una carpeta env en el root de nuestro proyecto, activara nuestro\nentorno virtual y crea nuestro archivo app.py\n\nPara poder usar nuestras librerías debemos instalarlas, en este caso haré uso de\nPIP que es nuestro gestor de paquetes en python y las librería a instalar son:\n\n * urllib3: Para realizar las consultas HTTP\n * json: para parsear la información recibida en la respuesta HTTP\n * jinja2: para renderizar nuestro archivo README con la potencia de esta\n   librería de plantillas\n\n$ pip install urllib3 json jinja2\n$ pip freeze > requirements.txt\n\n\nYa tenemos nuestras dependencias instaladas nuestras dependencias, así que\nprocederemos a crear nuestro script, quedándonos algo como esto:\n\nimport json\nimport urllib3\nfrom jinja2 import Environment, FileSystemLoader\n\n# Cantidad maxima de posts a mostrar\nMAX_POSTS = 5\n\n# Setup\nenv = Environment(loader=FileSystemLoader('.'))\nhttp = urllib3.PoolManager()\n\ndef get_latest_posts(max_posts=5):\n    r = http.request('GET', 'https://api.rss2json.com/v1/api.json?rss_url=https%3A%2F%2Frafnixg.dev%2Frss%2F')\n    data = json.loads(r.data.decode('utf-8'))['items']\n    return data[0:max_posts]\n\ndef render_readme(data):\n    template = env.get_template('README.template')\n    render = template.render(**data)\n    with open(\"README.md\", \"w\") as f:\n        f.write(render)\n\ndef main():\n\n    latest_posts = get_latest_posts(MAX_POSTS)\n    data = {\n        'latest_post': latest_posts\n    }\n    render_readme(data)\n\n\nif __name__ == \"__main__\":\n    main()\n\n\nLas primeras 3 lineas de nuestro código son básicamente la importación de las\nlibrerías y utilidades que vamos a usar, luego definimos una constante para el\nnumero máximo de post que vamos a escribir en nuestro archivo README.\n\nEl setup es donde indicamos a jinja en que fichero debe buscar los templates y\ncreamos una instancia que llamaremos http para nuestras consultas HTTP\n\nComo ven en la función get_latest_posts() es un simple petición GET a el\nenpoint, como parámetro le podemos limitar el numero de items que retornara\n\nEn la función render_readme() indicamos el archivo a usar como template,\ncargamos la data obtenida de los últimos post y lo renderizamos en nuestro\ntemplate para luego escribirlo en el archivo final README.md\n\nCon esto ya podemos correr nuestro script y ver como nos genera de forma\ndinámica nuestro archivo README.md\n\n$ ptyhon3 app.py\n\n\nNuestro script ya genere de forma dinámica nuestro archivo README.md, con este\nmismo enfoque se pueden agregar muchísimas mas funciones consultando a\ndiferentes servicios y editar desde el template como se va a renderizar esta\ninformación.\n\nEn la tercera y ultima parte veremos como automatizar la ejecución de nuestro\nscript y actualizar README.md en nuestro repositorio de GitHub, gracias a las\nGitHub Actions.\n\nGracias por leerme, los espero por twitter @rafnixg\n[https://twitter.com/rafnixg] y por mi GitHub rafnixg\n[https://github.com/rafnixg/rafnixg]\n\nSiguiente publicación de esta serie: Actualiza tu perfil de GitHub con README y\nGitHub Actions - Parte 3\n[/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-3/]","html":"<p></p><p>La idea principal es poder generar un archivo README.md con una lista de los últimos 5 post de este Blog, pero en esencia este código con muy poco o hasta nula modificacion en algunos casos puede servir para otros servicios como <a href=\"https://dev.to/\">dev.to</a>, <a href=\"https://medium.com/\">Medium</a> o WordPress.</p><p>Ya teniendo nuestro archivo README.md creado en el post <a href=\"http://localhost:2368/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-1/\">Actualiza tu perfil de GitHub con README y Github Actions - Parte 1</a> , nos ubicamos en la carpeta de nuestro proyecto y empezaremos creamos una copia de nuestro archivo pero con extensión <strong>.template</strong>, quedándonos algo como esto: README.md.template, este sera el archivo que usaremos como base para generar nuestro README.md</p><p>Luego editamos la sección de \"Latest post (Spanish)\" sustituyendo nuestros post estáticos con este código en Jinja2, que nos ayuda a iterar sobre una lista de post.</p><pre><code class=\"language-jinja\">## Latest Posts (Spanish)\n\n{% for post in latest_post %}\n- [{{post.title}}]({{post.link}})\n{%  endfor %}\n\n</code></pre><p>En esta plantilla indico que le voy a pasar <em>latest_post</em> y que debo recorrer sus post e imprimirlos dentro de un link en markdown.</p><p>Ahora necesitamos el endpoint a el que consultaremos para obtener nuestras lista de posts, para esto haré uso de las <a href=\"https://es.wikipedia.org/wiki/RSS\">RSS</a> que tiene Ghost y con el siguiente servicio lo convertiré de XML a JSON</p><figure class=\"kg-card kg-bookmark-card\"><a class=\"kg-bookmark-container\" href=\"https://rss2json.com\"><div class=\"kg-bookmark-content\"><div class=\"kg-bookmark-title\">Rss to json online converter - rss2json.com</div><div class=\"kg-bookmark-description\">Free online API to convert RSS to JSON</div><div class=\"kg-bookmark-metadata\"><img class=\"kg-bookmark-icon\" src=\"https://rss2json.com/favicon.ico\"><span class=\"kg-bookmark-publisher\">rss2json</span></div></div><div class=\"kg-bookmark-thumbnail\"><img src=\"https://rss2json.com/rss2json_logo.png\"></div></a></figure><p>Acá pudimos haberlo hecho de muchas maneras distintas, se pudo haber usado la API ded Ghost y hacer la petición directa o se pudo haber hecho el cambio de XML a JSON usando Python, mi idea era hacerlo lo mas simple posible, si tienes una idea mejor la espero en los comentarios o un Pull Request, ya con esto aclarado podemos continuar xD.</p><p>Teniendo nuestro endpoint listo procederemos a crear nuestro script en Python, por lo que primero debemos preparar, es nuestro entorno virtual que nos ayude a aislar nuestras dependencias para este proyecto, podemos hacer uso de Pipenv del cual tengo un tutorial por acá (<a href=\"http://localhost:2368/entornos-virtuales-en-python-usando-pipenv/\">Entornos virtuales en python usando Pipenv</a>), pero en este caso lo haremos de la siguiente manera ya que es la mas comun.</p><pre><code class=\"language-bash\">$ python3 -m venv env\n$ source env/bin/activate\n$ touch app.py\n</code></pre><p>Lo que creara una carpeta <em>env</em> en el <em>root</em> de nuestro proyecto, activara nuestro entorno virtual y crea nuestro archivo <strong>app.py</strong></p><p>Para poder usar nuestras librerías debemos instalarlas, en este caso haré uso de PIP que es nuestro gestor de paquetes en python y las librería a instalar son:</p><ul><li><strong>urllib3</strong>: Para realizar las consultas HTTP</li><li><strong>json</strong>: para parsear la información recibida en la respuesta HTTP</li><li><strong>jinja2</strong>: para renderizar nuestro archivo README con la potencia de esta librería de plantillas</li></ul><pre><code class=\"language-bash\">$ pip install urllib3 json jinja2\n$ pip freeze &gt; requirements.txt\n</code></pre><p>Ya tenemos nuestras dependencias instaladas nuestras dependencias, así que procederemos a crear nuestro script, quedándonos algo como esto:</p><pre><code class=\"language-python\">import json\nimport urllib3\nfrom jinja2 import Environment, FileSystemLoader\n\n# Cantidad maxima de posts a mostrar\nMAX_POSTS = 5\n\n# Setup\nenv = Environment(loader=FileSystemLoader('.'))\nhttp = urllib3.PoolManager()\n\ndef get_latest_posts(max_posts=5):\n    r = http.request('GET', 'https://api.rss2json.com/v1/api.json?rss_url=https%3A%2F%2Frafnixg.dev%2Frss%2F')\n    data = json.loads(r.data.decode('utf-8'))['items']\n    return data[0:max_posts]\n\ndef render_readme(data):\n    template = env.get_template('README.template')\n    render = template.render(**data)\n    with open(\"README.md\", \"w\") as f:\n        f.write(render)\n\ndef main():\n\n    latest_posts = get_latest_posts(MAX_POSTS)\n    data = {\n        'latest_post': latest_posts\n    }\n    render_readme(data)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre><p>Las primeras 3 lineas de nuestro código son básicamente la importación de las librerías y utilidades que vamos a usar, luego definimos una constante para el numero máximo de post que vamos a escribir en nuestro archivo README.</p><p>El setup es donde indicamos a jinja en que fichero debe buscar los templates y creamos una instancia que llamaremos http para nuestras consultas HTTP</p><p>Como ven en la función <em>get_latest_posts()</em> es un simple petición GET a el enpoint, como parámetro le podemos limitar el numero de items que retornara</p><p>En la función <em>render_readme() </em>indicamos el archivo a usar como template, cargamos la data obtenida de los últimos post y lo renderizamos en nuestro template para luego escribirlo en el archivo final README.md</p><p>Con esto ya podemos correr nuestro script y ver como nos genera de forma dinámica nuestro archivo README.md</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ ptyhon3 app.py\n</code></pre>\n<!--kg-card-end: markdown--><p>Nuestro script ya genere de forma dinámica nuestro archivo README.md, con este mismo enfoque se pueden agregar muchísimas mas funciones consultando a diferentes servicios y editar desde el template como se va a renderizar esta información.</p><p>En la tercera y ultima parte veremos como automatizar la ejecución de nuestro script y actualizar README.md en nuestro repositorio de GitHub, gracias a las GitHub Actions.</p><p>Gracias por leerme, los espero por twitter <a href=\"https://twitter.com/rafnixg\">@rafnixg</a> y por mi GitHub <a href=\"https://github.com/rafnixg/rafnixg\">rafnixg</a></p><p>Siguiente publicación de esta serie: <a href=\"http://localhost:2368/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-3/\">Actualiza tu perfil de GitHub con README y GitHub Actions - Parte 3</a></p>","url":"http://localhost:2368/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-2/","canonical_url":null,"uuid":"924c8656-d63b-4a15-9f9d-c1094f418d0f","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f2079b92f13451cfdfd94a8","reading_time":3}},{"node":{"id":"Ghost__Post__5f330dd9c6b819e6351398d7","title":"Actualiza tu perfil de GitHub con README y GitHub Actions - Parte 1","slug":"actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-1","featured":true,"feature_image":"https://images.unsplash.com/photo-1590595906931-81f04f0ccebb?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ","excerpt":"Github ha lanzado una nueva funcionalidad para nuestro perfil de usuario, acá te enseño como publique y automatice el mio!","custom_excerpt":"Github ha lanzado una nueva funcionalidad para nuestro perfil de usuario, acá te enseño como publique y automatice el mio!","visibility":"public","created_at_pretty":"27 July, 2020","published_at_pretty":"28 July, 2020","updated_at_pretty":"09 August, 2020","created_at":"2020-07-26T19:25:04.000-05:00","published_at":"2020-07-28T16:35:14.000-05:00","updated_at":"2020-08-08T20:02:44.000-05:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Rafnix Guzmán","slug":"rafnix","bio":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Rafnix Guzmán","slug":"rafnix","bio":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"github","slug":"github","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"github","slug":"github","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"python","slug":"python","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"markdown","slug":"markdown","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"\n\nEsta sera una serie de 3 Post:\n\n * Crear nuestro README en GitHub\n   [/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-1/]\n * Escribir un script en python para crear nuestro README dinámico\n   [/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-2/]\n * Implementar GitHub Actions para automatizar nuestro README\n   [/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-3/]\n\n Acá te dejo una mirada de como quedo mi perfil [https://github.com/rafnixg],\nespero me dejes una estrella :D\n\n\n\nPreparando nuestro repositorio\nPara iniciar, debemos crear un repositorio en GitHub con nuestro nombre de\nusuario, en mi caso \"rafnixg\", tiene que ser publico y estar inicializado con un\narchivo README.\n\nIngresando a https://github.com/new podemos crear nuestro repositorio\n\nEn mi caso ya me indica que tengo este repositorio creado, pero ademas se ve un\nmensaje que nos indica que activamos esta funcionalidad \"secreta\"\n\nCreando nuestro README\nEn esta parte del proceso tendremos que empezar clonando nuestro repositorio y\neditar nuestro archivo README con la información que quisiéramos mostrar, para\nesto usaremos el siguiente comando de Git:\n\n$ git clone https://github.com/tu_username/tu_username.git\n\n\nLuego de clonar nuestro repositorio procedemos a crear nuestro archivo README\nusando Markdown, yo en esta parte del proceso use varias referencias para tomar\nideas y armar algo que me gustara, les dejo por acá los enlaces para que las\nvisiten y tomen ideas.\n\n * https://github.com/kautukkundan/Awesome-Profile-README-templates\n * https://github.com/abhisheknaiidu/awesome-github-profile-readme\n\nYa con una idea de lo que queremos hacer, escribimos nuestro archivo y subimos\nestos cambios a GitHub\n\n$ git add README.md\n$ git commit -m \"[IMP] Mejora de nuestro README\"\n$ git push -u origin master\n\n\nCon esto ya tendremos nuestro archivo README desplegado en nuestro perfil de\nGitHub.\n\nEn la segunda entrega veremos como poder obtener datos de una API como la Ghost\no Dev.to y actualizar nuestro archivo README usando Python.\n\nSiguiente de esta serie: Escribir un script en python para crear nuestro README\ndinámico [/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-2/]\n\nGracias por leerme! los espero por mi twitter @rafnixg\n[https://rafnixg@gmail.com]","html":"<p></p><p>Esta sera una serie de 3 Post:</p><ul><li><a href=\"http://localhost:2368/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-1/\">Crear nuestro README en GitHub</a></li><li><a href=\"http://localhost:2368/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-2/\">Escribir un script en python para crear nuestro README dinámico</a></li><li><a href=\"http://localhost:2368/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-3/\">Implementar GitHub Actions para automatizar nuestro README</a></li></ul><p> Acá te dejo una mirada de como quedo <a href=\"https://github.com/rafnixg\">mi perfil</a>, espero me dejes una estrella :D</p><!--kg-card-begin: markdown--><p><img src=\"https://raw.githubusercontent.com/rafnixg/rafnixg/master/readme.md.png\" alt=\"Rafnixg github profile\"></p>\n<!--kg-card-end: markdown--><h2 id=\"preparando-nuestro-repositorio\">Preparando nuestro repositorio</h2><p>Para iniciar, debemos crear un repositorio en GitHub con nuestro nombre de usuario, en mi caso \"rafnixg\", tiene que ser publico y estar inicializado con un archivo README.</p><p>Ingresando a <a href=\"https://github.com/new\">https://github.com/new</a> podemos crear nuestro repositorio</p><figure class=\"kg-card kg-image-card\"><img src=\"http://localhost:2368/content/images/2020/07/Screenshot_2020-07-26-Build-software-better--together.png\" class=\"kg-image\" alt srcset=\"http://localhost:2368/content/images/size/w600/2020/07/Screenshot_2020-07-26-Build-software-better--together.png 600w, http://localhost:2368/content/images/2020/07/Screenshot_2020-07-26-Build-software-better--together.png 819w\" sizes=\"(min-width: 720px) 720px\"></figure><p>En mi caso ya me indica que tengo este repositorio creado, pero ademas se ve un mensaje que nos indica que activamos esta funcionalidad \"secreta\"</p><figure class=\"kg-card kg-image-card\"><img src=\"http://localhost:2368/content/images/2020/07/Screenshot_2020-07-26-Build-software-better--together-1-.png\" class=\"kg-image\" alt srcset=\"http://localhost:2368/content/images/size/w600/2020/07/Screenshot_2020-07-26-Build-software-better--together-1-.png 600w, http://localhost:2368/content/images/2020/07/Screenshot_2020-07-26-Build-software-better--together-1-.png 704w\"></figure><h2 id=\"creando-nuestro-readme\">Creando nuestro README</h2><p>En esta parte del proceso tendremos que empezar clonando nuestro repositorio y editar nuestro archivo README con la información que quisiéramos mostrar, para esto usaremos el siguiente comando de Git:</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ git clone https://github.com/tu_username/tu_username.git\n</code></pre>\n<!--kg-card-end: markdown--><p>Luego de clonar nuestro repositorio procedemos a crear nuestro archivo README usando Markdown, yo en esta parte del proceso use varias referencias para tomar ideas y armar algo que me gustara, les dejo por acá los enlaces para que las visiten y tomen ideas.</p><ul><li><a href=\"https://github.com/kautukkundan/Awesome-Profile-README-templates\">https://github.com/kautukkundan/Awesome-Profile-README-templates</a></li><li><a href=\"https://github.com/abhisheknaiidu/awesome-github-profile-readme\">https://github.com/abhisheknaiidu/awesome-github-profile-readme</a></li></ul><p>Ya con una idea de lo que queremos hacer, escribimos nuestro archivo y subimos estos cambios a GitHub</p><!--kg-card-begin: markdown--><pre><code class=\"language-bash\">$ git add README.md\n$ git commit -m &quot;[IMP] Mejora de nuestro README&quot;\n$ git push -u origin master\n</code></pre>\n<!--kg-card-end: markdown--><p>Con esto ya tendremos nuestro archivo README desplegado en nuestro perfil de GitHub.</p><p>En la segunda entrega veremos como poder obtener datos de una API como la Ghost o Dev.to y actualizar nuestro archivo README usando Python.</p><p>Siguiente de esta serie: <a href=\"http://localhost:2368/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-2/\">Escribir un script en python para crear nuestro README dinámico</a></p><p>Gracias por leerme! los espero por mi twitter <a href=\"https://rafnixg@gmail.com\">@rafnixg</a></p>","url":"http://localhost:2368/actualiza-tu-perfil-de-github-con-readme-y-github-actions-part-1/","canonical_url":null,"uuid":"d32b6865-d64a-40c8-bd49-5cf124dadf3a","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f1e1ee02f13451cfdfd931d","reading_time":2}},{"node":{"id":"Ghost__Post__5f330dd9c6b819e6351398d6","title":"Crea tu blog con python usando GitHub Pages y Pelican","slug":"crea-tu-blog-con-python-usando-github-pages-y-pelican","featured":false,"feature_image":"https://images.unsplash.com/photo-1522542550221-31fd19575a2d?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ","excerpt":"Cuando comencé a darle vuelta a la idea de empezar un blog de nuevo me vinieron\nmuchas ideas de como hacerlo a la mente, como el de usar el famoso Wordpress\n[https://wordpress.org], teniendo en cuenta que el blog lo quería hacer para\nhablar un poco de python y las tecnologías que iba a ir conociendo y aprendiendo\ndecidí mejor usar Pelican ya que esta desarrollado en Python.\n\n¿Qué es Pelican?\nPelican [https://blog.getpelican.com/] es un generador de sitios estáticos\ndesarrollado en python que nos","custom_excerpt":null,"visibility":"public","created_at_pretty":"22 July, 2020","published_at_pretty":"18 May, 2019","updated_at_pretty":"22 July, 2020","created_at":"2020-07-22T14:03:32.000-05:00","published_at":"2019-05-18T14:06:00.000-05:00","updated_at":"2020-07-22T14:07:27.000-05:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Rafnix Guzmán","slug":"rafnix","bio":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Rafnix Guzmán","slug":"rafnix","bio":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"python","slug":"python","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"python","slug":"python","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},{"name":"github","slug":"github","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Cuando comencé a darle vuelta a la idea de empezar un blog de nuevo me vinieron\nmuchas ideas de como hacerlo a la mente, como el de usar el famoso Wordpress\n[https://wordpress.org], teniendo en cuenta que el blog lo quería hacer para\nhablar un poco de python y las tecnologías que iba a ir conociendo y aprendiendo\ndecidí mejor usar Pelican ya que esta desarrollado en Python.\n\n¿Qué es Pelican?\nPelican [https://blog.getpelican.com/] es un generador de sitios estáticos\ndesarrollado en python que nos permite escribir los post en archivos escritos en\nreStructuredText, Markdown, o AsciiDoc, y estos serán luego procesados para\ngenerar un sitio web estático como este blog, por lo que no necesitaremos una\nbase de datos ni un servidor web que soporte un lenguaje de Backend como lo es\nGitHub Pages.\n\n¿Qué es GitHub Pages?\nGitHub Pages [https://pages.github.com/] es un hosting de sitios estáticos y\ncomo su pagina web lo indica, esta diseñado para hostear directamente en un\nrepositorio de GitHub la pagina web de nuestros proyecto, paginas personales o\nde organizaciones, ademas de ser un servicio gratuito.\n\nGracias a estas características, podemos fácilmente crear nuestros sitios\nestáticos y subirlos a un repositorio de GitHub que debe tener la siguiente\nestructura username.github.io mas adelante indicare como crear y configurar el\nrepositorio para que pueda servir nuestro sitio web.\n\nGitHub recomienda el uso de Jekyll [https://jekyllrb.com/] para generar nuestros\nsitios estáticos, pero este esta hecho en Ruby, lo que no es un problema si usas\nRuby pero yo al ser un #PythonLover decidí usar Pelican que esta desarrollado en\nPython.\n\nCreando nuestro repositorio en GitHub\nEsta parte es la mas sencilla de post, ya que solo debemos entrar a nuestra\ncuenta de GitHub y crear un nuevo repositorio publico, que tenga el siguiente\nnombre.\n\ntu_username.github.io, en mi caso el repositorio donde se aloja este blog se\nllama rafnixg.github.io [https://rafnixg.github.io]\n\nSolo con esto ya tendremos nuestro Github Pages listo para comenzar a subir\nnuestro contenido estático.\n\nInstalando y configurando Pelican\nInstalar y tener Pelican funcionando es super sencillo. Pero si les quiero\nrecomendar que toda la instalación se haga en un entorno virtual usando Pipenv,\npara mantener separado esta instalación de los demás paquetes de Python que\ntengan instalados en sus sistema, si no saben como usar Pipenv acá les dejo un\npost que tengo sobre este tema, Entornos virtuales en Python usando Pipenv.\n\nAntes de iniciar con la instalación de pelican, debemos clonar nuestro\nrepositorio donde esta hosteada nuestro blog, para esto solo debemos ubicarnos\nsonde queramos tener nuestro proyecto, en este caso yo lo haré en la raíz de mi\nsistema.\n\n$ cd ~\n$ git clone https://github.com/tu_username/tu_username.github.io.git\n$ cd tu_username.github.io\n\n\nLuego de esto, procedemos a instalar nuestro Pelican, lo primero que debemos\nhacer es crear un nuevo branch llamado source donde ira todo nuestro código\nfuente y librerías, ya que para GitHub todo lo que este en la rama master es lo\nque sera servido, para nuestro interés solo debemos subir a master lo que\npelican genera en su carpeta output, pero mas adelante nos preocuparemos de\nesto.\n\n$ git checkout -b source\n$ pipenv shell\n\n\nCon esto ya tendremos nuestro entorno virtual para nuestra instalación de\npelican, ahora procedemos a instalar pelican que es nuestro generador de sitios\nestáticos, markdown que nos ayudara para escribir nuestros post usando este\nlenguaje y ghp-import que nos ayuda a publicar nuestro sitio a GitHub.\n\n$ pipenv install pelican markdown ghp-import\n\nInstalling pelican…\nAdding pelican to Pipfile's [packages]…\n✔ Installation Succeeded \nInstalling markdown…\nAdding markdown to Pipfile's [packages]…\n✔ Installation Succeeded \nInstalling ghp-import…\nAdding ghp-import to Pipfile's [packages]…\n✔ Installation Succeeded \nPipfile.lock not found, creating…\nLocking [dev-packages] dependencies…\nLocking [packages] dependencies…\n✔ Success! \nUpdated Pipfile.lock (b0c318)!\nInstalling dependencies from Pipfile.lock (b0c318)…\n  🐍   ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ 13/13 — \n\n\nYa con esto tenemos todo listo para empezar a usar Pelican así que creemos\nnuestro primer blog usándolo.\n\n$ pelican-quickstart\n\nWelcome to pelican-quickstart v4.0.1.\n\nThis script will help you create a new Pelican-based website.\n\nPlease answer the following questions so this script can generate the files\nneeded by Pelican.\n    \nUsing project associated with current virtual environment.Will save to:\n/home/username/blog/pelican\n\n> What will be the title of this web site? prueba pelican\n> Who will be the author of this web site? rafnix guzman\n> What will be the default language of this web site? [es] es\n> Do you want to specify a URL prefix? e.g., https://example.com   (Y/n) n\n> Do you want to enable article pagination? (Y/n) y\n> How many articles per page do you want? [10] \n> What is your time zone? [Europe/Paris] America/Lima\n> Do you want to generate a tasks.py/Makefile to automate generation and publishing? (Y/n) Y **# Responder Y, esto nos ayuda mucho!**\n> Do you want to upload your website using FTP? (y/N) n\n> Do you want to upload your website using SSH? (y/N) n\n> Do you want to upload your website using Dropbox? (y/N) n\n> Do you want to upload your website using S3? (y/N) n\n> Do you want to upload your website using Rackspace Cloud Files? (y/N) n\n> Do you want to upload your website using GitHub Pages? (y/N) y\n> Is this your personal page (username.github.io)? (y/N) y\nDone. Your new project is available at /home/username/blog/pelican\n\n\nSi tienen alguna duda respecto a la zona horaria acá les dejo una lista con\ntodas las zonas horarias\n[https://en.wikipedia.org/wiki/List_of_tz_database_time_zones]\n\n> Do you want to generate a tasks.py/Makefile to automate generation and publishing? (Y/n)\n\n\nA esta pregunta deben responder (Y), ya que este Makefile nos ayudara a generar\nnuestro sitio de forma mas fácil, como podemos ver ya con esto se nos ha\ngenerado nuestro proyecto de pelican con el que podemos empezar a trabajar.\n\nEscribiendo nuestro primer post\nVamos a crear nuestro primer post, para esto nos debemos ubicar en la carpeta \ncontent y con nuestro editor de texto favorito procedemos a crear un archivo\nllamado hola-mundo.md (si, lo se, la imaginación esta a la orden del día), este\narchivo luego puede ser borrado es solo para pruebas.\n\nTitle: Hola Mundo\nDate: 2019-05-18 10:30\nModified: 2019-05-18 11:30\nCategory: blog\nTags: principal, otros\nSlug: hola-mundo\nAuthors: Rafnix Guzmán\nSummary: Mi primer post usando Pelican y GitHub Pages\n\nAca pueden empezar a escribir todo lo que quieran pueden agregar todas las sintaxis de *Markdown* que deseen.\n\n## Título\n### Subtítulo\nEste es un ejemplo de texto que da entrada a una lista genérica de elementos:\n\n- Elemento 1\n- Elemento 2\n- Elemento 3\n\nEste es un ejemplo de texto que da entrada a una lista numerada:\n\n1. Elemento 1\n2. Elemento 2\n3. Elemento 3\n\nAl texto en Markdown puedes añadirle formato como **negrita** o *cursiva* de una manera muy sencilla.\n\nTodo esto fue extraído de este [Post sobre markdown](https://markdown.es/sintaxis-markdown/)\n\n\nProbando nuestro blog en local\nLuego de escribir y guardar su primer post, procedemos a generar un servidor de\npruebas para ver nuestro resultado antes de subir nuestra web a GitHub, estando\nen la raíz de nuestro proyecto ejecutamos el siguiente comando.\n\n$ make devserver\n\npelican -lr /home/username/blog/pelican/content -o /home/username/blog/pelican/output -s /home/username/blog/pelican/pelicanconf.py \n\n-> Modified: content, theme, settings. re-generating...\nDone: Processed 1 article, 0 drafts, 0 pages, 0 hidden pages and 0 draft pages in 0.15 seconds.\n\n\nPara entrar a nuestro servidor local de pruebas debemos ingresar a la siguiente\nURL http://localhost:8000 con nuestro explorador favorito(espero no se IE, xD)\n\nHola mundo pelicanSubir nuestro blog a GitHub Pages\nYa con esto procederemos a preparar todo para subir lo a github, este primer\ncomando sube nuestro código fuente.\n\n$ git add -A && git commit -a -m 'post hola-mundo.md' && git push --all\n\n\nAhora subimos todo a la rama master, recuerdan que les dije que no se\npreocuparan por esto, es debido a que este comando hace toda esta preparación de\nsubir todo lo que se encuentra en la carpeta output a nuestra rama master\n\n$ make github\n\n\nAcá se les preguntaran sus credenciales de github, para poder subir a su\nrepositorio todo el sitio estático ya generado, con esto su blog estará\nfuncionando en https://su_username.github.io/\n\nPara el próximo post veremos como configurar un Thema y algunos Plugins para\npotenciar el funcionamiento de Pelican, ademas de unas configuraciones extra que\nnos ayudaran a tener mejor SEO.\n\nNos vemos en el proximo post, muchas gracias por leerme y cualquier duda,\ncomentario, o lo que sea, lo pueden dejar por aca o por mi cuenta de Twitter \n@rafnixg [https://twitter.com/rafnixg].","html":"<p>Cuando comencé a darle vuelta a la idea de empezar un blog de nuevo me vinieron muchas ideas de como hacerlo a la mente, como el de usar el famoso <a href=\"https://wordpress.org\">Wordpress</a>, teniendo en cuenta que el blog lo quería hacer para hablar un poco de python y las tecnologías que iba a ir conociendo y aprendiendo decidí mejor usar Pelican ya que esta desarrollado en Python.</p><h2 id=\"-qu-es-pelican\">¿Qué es Pelican?</h2><p><a href=\"https://blog.getpelican.com/\">Pelican</a> es un generador de sitios estáticos desarrollado en python que nos permite escribir los post en archivos escritos en reStructuredText, Markdown, o AsciiDoc, y estos serán luego procesados para generar un sitio web estático como este blog, por lo que no necesitaremos una base de datos ni un servidor web que soporte un lenguaje de Backend como lo es GitHub Pages.</p><h2 id=\"-qu-es-github-pages\">¿Qué es GitHub Pages?</h2><p><a href=\"https://pages.github.com/\">GitHub Pages</a> es un hosting de sitios estáticos y como su pagina web lo indica, esta diseñado para hostear directamente en un repositorio de GitHub la pagina web de nuestros proyecto, paginas personales o de organizaciones, ademas de ser un servicio gratuito.</p><p>Gracias a estas características, podemos fácilmente crear nuestros sitios estáticos y subirlos a un repositorio de GitHub que debe tener la siguiente estructura <code>username.github.io</code> mas adelante indicare como crear y configurar el repositorio para que pueda servir nuestro sitio web.</p><p>GitHub recomienda el uso de <a href=\"https://jekyllrb.com/\">Jekyll</a> para generar nuestros sitios estáticos, pero este esta hecho en Ruby, lo que no es un problema si usas Ruby pero yo al ser un #PythonLover decidí usar Pelican que esta desarrollado en Python.</p><h2 id=\"creando-nuestro-repositorio-en-github\">Creando nuestro repositorio en GitHub</h2><p>Esta parte es la mas sencilla de post, ya que solo debemos entrar a nuestra cuenta de GitHub y crear un nuevo repositorio publico, que tenga el siguiente nombre.</p><p><code>tu_username.github.io</code>, en mi caso el repositorio donde se aloja este blog se llama <a href=\"https://rafnixg.github.io\">rafnixg.github.io</a></p><p>Solo con esto ya tendremos nuestro Github Pages listo para comenzar a subir nuestro contenido estático.</p><h2 id=\"instalando-y-configurando-pelican\">Instalando y configurando Pelican</h2><p>Instalar y tener Pelican funcionando es super sencillo. Pero si les quiero recomendar que toda la instalación se haga en un entorno virtual usando Pipenv, para mantener separado esta instalación de los demás paquetes de Python que tengan instalados en sus sistema, si no saben como usar Pipenv acá les dejo un post que tengo sobre este tema, <a>Entornos virtuales en Python usando Pipenv</a>.</p><p>Antes de iniciar con la instalación de pelican, debemos clonar nuestro repositorio donde esta hosteada nuestro blog, para esto solo debemos ubicarnos sonde queramos tener nuestro proyecto, en este caso yo lo haré en la raíz de mi sistema.</p><pre><code class=\"language-bash\">$ cd ~\n$ git clone https://github.com/tu_username/tu_username.github.io.git\n$ cd tu_username.github.io\n</code></pre><p>Luego de esto, procedemos a instalar nuestro Pelican, lo primero que debemos hacer es crear un nuevo branch llamado <code>source</code> donde ira todo nuestro código fuente y librerías, ya que para GitHub todo lo que este en la rama <code>master</code> es lo que sera servido, para nuestro interés solo debemos subir a <code>master</code> lo que pelican genera en su carpeta output, pero mas adelante nos preocuparemos de esto.</p><pre><code class=\"language-sh\">$ git checkout -b source\n$ pipenv shell\n</code></pre><p>Con esto ya tendremos nuestro entorno virtual para nuestra instalación de pelican, ahora procedemos a instalar <code>pelican</code> que es nuestro generador de sitios estáticos, <code>markdown</code> que nos ayudara para escribir nuestros post usando este lenguaje y <code>ghp-import</code> que nos ayuda a publicar nuestro sitio a GitHub.</p><pre><code class=\"language-sh\">$ pipenv install pelican markdown ghp-import\n\nInstalling pelican…\nAdding pelican to Pipfile's [packages]…\n✔ Installation Succeeded \nInstalling markdown…\nAdding markdown to Pipfile's [packages]…\n✔ Installation Succeeded \nInstalling ghp-import…\nAdding ghp-import to Pipfile's [packages]…\n✔ Installation Succeeded \nPipfile.lock not found, creating…\nLocking [dev-packages] dependencies…\nLocking [packages] dependencies…\n✔ Success! \nUpdated Pipfile.lock (b0c318)!\nInstalling dependencies from Pipfile.lock (b0c318)…\n  🐍   ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ 13/13 — \n</code></pre><p>Ya con esto tenemos todo listo para empezar a usar Pelican así que creemos nuestro primer blog usándolo.</p><pre><code class=\"language-sh\">$ pelican-quickstart\n\nWelcome to pelican-quickstart v4.0.1.\n\nThis script will help you create a new Pelican-based website.\n\nPlease answer the following questions so this script can generate the files\nneeded by Pelican.\n    \nUsing project associated with current virtual environment.Will save to:\n/home/username/blog/pelican\n\n&gt; What will be the title of this web site? prueba pelican\n&gt; Who will be the author of this web site? rafnix guzman\n&gt; What will be the default language of this web site? [es] es\n&gt; Do you want to specify a URL prefix? e.g., https://example.com   (Y/n) n\n&gt; Do you want to enable article pagination? (Y/n) y\n&gt; How many articles per page do you want? [10] \n&gt; What is your time zone? [Europe/Paris] America/Lima\n&gt; Do you want to generate a tasks.py/Makefile to automate generation and publishing? (Y/n) Y **# Responder Y, esto nos ayuda mucho!**\n&gt; Do you want to upload your website using FTP? (y/N) n\n&gt; Do you want to upload your website using SSH? (y/N) n\n&gt; Do you want to upload your website using Dropbox? (y/N) n\n&gt; Do you want to upload your website using S3? (y/N) n\n&gt; Do you want to upload your website using Rackspace Cloud Files? (y/N) n\n&gt; Do you want to upload your website using GitHub Pages? (y/N) y\n&gt; Is this your personal page (username.github.io)? (y/N) y\nDone. Your new project is available at /home/username/blog/pelican\n</code></pre><p>Si tienen alguna duda respecto a la zona horaria acá les dejo una lista con todas las <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\">zonas horarias</a></p><pre><code class=\"language-sh\">&gt; Do you want to generate a tasks.py/Makefile to automate generation and publishing? (Y/n)\n</code></pre><p>A esta pregunta deben responder (Y), ya que este Makefile nos ayudara a generar nuestro sitio de forma mas fácil, como podemos ver ya con esto se nos ha generado nuestro proyecto de pelican con el que podemos empezar a trabajar.</p><h2 id=\"escribiendo-nuestro-primer-post\">Escribiendo nuestro primer post</h2><p>Vamos a crear nuestro primer post, para esto nos debemos ubicar en la carpeta <code>content</code> y con nuestro editor de texto favorito procedemos a crear un archivo llamado hola-mundo.md (si, lo se, la imaginación esta a la orden del día), este archivo luego puede ser borrado es solo para pruebas.</p><pre><code class=\"language-markdown\">Title: Hola Mundo\nDate: 2019-05-18 10:30\nModified: 2019-05-18 11:30\nCategory: blog\nTags: principal, otros\nSlug: hola-mundo\nAuthors: Rafnix Guzmán\nSummary: Mi primer post usando Pelican y GitHub Pages\n\nAca pueden empezar a escribir todo lo que quieran pueden agregar todas las sintaxis de *Markdown* que deseen.\n\n## Título\n### Subtítulo\nEste es un ejemplo de texto que da entrada a una lista genérica de elementos:\n\n- Elemento 1\n- Elemento 2\n- Elemento 3\n\nEste es un ejemplo de texto que da entrada a una lista numerada:\n\n1. Elemento 1\n2. Elemento 2\n3. Elemento 3\n\nAl texto en Markdown puedes añadirle formato como **negrita** o *cursiva* de una manera muy sencilla.\n\nTodo esto fue extraído de este [Post sobre markdown](https://markdown.es/sintaxis-markdown/)\n</code></pre><h2 id=\"probando-nuestro-blog-en-local\">Probando nuestro blog en local</h2><p>Luego de escribir y guardar su primer post, procedemos a generar un servidor de pruebas para ver nuestro resultado antes de subir nuestra web a GitHub, estando en la raíz de nuestro proyecto ejecutamos el siguiente comando.</p><pre><code class=\"language-sh\">$ make devserver\n\npelican -lr /home/username/blog/pelican/content -o /home/username/blog/pelican/output -s /home/username/blog/pelican/pelicanconf.py \n\n-&gt; Modified: content, theme, settings. re-generating...\nDone: Processed 1 article, 0 drafts, 0 pages, 0 hidden pages and 0 draft pages in 0.15 seconds.\n</code></pre><p>Para entrar a nuestro servidor local de pruebas debemos ingresar a la siguiente URL <a href=\"http://localhost:8000\">http://localhost:8000</a> con nuestro explorador favorito(espero no se IE, xD)</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"http://localhost:2368/content/images/2020/07/hola-mundo-pelican.jpg\" class=\"kg-image\" alt=\"Hola mundo Pelican\" srcset=\"http://localhost:2368/content/images/size/w600/2020/07/hola-mundo-pelican.jpg 600w, http://localhost:2368/content/images/2020/07/hola-mundo-pelican.jpg 944w\" sizes=\"(min-width: 720px) 720px\"><figcaption>Hola mundo pelican</figcaption></figure><h2 id=\"subir-nuestro-blog-a-github-pages\">Subir nuestro blog a GitHub Pages</h2><p>Ya con esto procederemos a preparar todo para subir lo a github, este primer comando sube nuestro código fuente.</p><pre><code class=\"language-bash\">$ git add -A &amp;&amp; git commit -a -m 'post hola-mundo.md' &amp;&amp; git push --all\n</code></pre><p>Ahora subimos todo a la rama <code>master</code>, recuerdan que les dije que no se preocuparan por esto, es debido a que este comando hace toda esta preparación de subir todo lo que se encuentra en la carpeta <code>output</code> a nuestra rama <code>master</code></p><pre><code class=\"language-bash\">$ make github\n</code></pre><p>Acá se les preguntaran sus credenciales de github, para poder subir a su repositorio todo el sitio estático ya generado, con esto su blog estará funcionando en https://su_username.github.io/</p><p>Para el próximo post veremos como configurar un <code>Thema</code> y algunos <code>Plugins</code> para potenciar el funcionamiento de Pelican, ademas de unas configuraciones extra que nos ayudaran a tener mejor SEO.</p><p>Nos vemos en el proximo post, muchas gracias por leerme y cualquier duda, comentario, o lo que sea, lo pueden dejar por aca o por mi cuenta de Twitter <a href=\"https://twitter.com/rafnixg\">@rafnixg</a>.</p>","url":"http://localhost:2368/crea-tu-blog-con-python-usando-github-pages-y-pelican/","canonical_url":null,"uuid":"c96bd5a6-1290-473e-a000-3bd5293463ec","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f188d842f13451cfdfd9302","reading_time":6}},{"node":{"id":"Ghost__Post__5f330dd9c6b819e6351398d2","title":"🐍 Entornos virtuales en Python usando Pipenv","slug":"entornos-virtuales-en-python-usando-pipenv","featured":true,"feature_image":"https://images.unsplash.com/photo-1515879218367-8466d910aaa4?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ","excerpt":"Una pequeña guía de como usar entornos virtuales de forma fácil en Python","custom_excerpt":"Una pequeña guía de como usar entornos virtuales de forma fácil en Python","visibility":"public","created_at_pretty":"27 June, 2020","published_at_pretty":"12 May, 2019","updated_at_pretty":"22 July, 2020","created_at":"2020-06-27T00:02:48.000-05:00","published_at":"2019-05-11T19:39:00.000-05:00","updated_at":"2020-07-22T16:54:23.000-05:00","meta_title":"🐍 Entornos virtuales en Python usando Pipenv","meta_description":"Una pequeña guía de como usar entornos virtuales de forma fácil en Python","og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Rafnix Guzmán","slug":"rafnix","bio":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Rafnix Guzmán","slug":"rafnix","bio":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"python","slug":"python","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"python","slug":"python","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Cuando iniciamos en el desarrollo con Python muchas veces no nos damos cuenta\ndel dolor de cabeza que es mantener varios proyectos con diferentes versiones de\ndependencias en nuestra entorno de desarrollo local, a medida que vamos\nevolucionando vamos adquiriendo nuevas herramientas que mejoren nuestro flujo de\ntrabajo, como el uso de entornos virtuales o manejadores de paquetes, entre\notras, Pipenv es una de estas herramientas que nos ayudan mucho a integrar y\nmejorar nuestros flujos en Python, tanto es así que su eslogan por así decirlo\nes \"Python Development Workflow for Humans\".\n\nEsta herramienta básicamente nos ayuda a optimizar nuestro flujo de desarrollo\nunificando pip y virtualenv en una sola herramienta que funciona por linea de\ncomandos (Terminal), lo que nos daria un entorno aislado en el cual instalar\nnuestras dependencia y luego replicar este mismo entorno en otra maquina gracias\na el archivo que se genera Pipfile [https://github.com/pypa/pipfile], que viene\na ser el sustituto del archivo que genera pip requirements.txt\n\nInstalando Pipenv\nEl proceso de instalación de Pipenv es muy sencillo, en esta ocasión voy a\ndetallar 2 formas de instalar usando lo indicado en la documentación oficial\n[https://pipenv-es.readthedocs.io/es/latest/].\n\nSi estas usando Ubuntu 16.04:\n\n$ sudo apt install software-properties-common python-software-properties\n$ sudo add-apt-repository ppa:pypa/ppa\n$ sudo apt update\n$ sudo apt install pipenv\n\n\nEsta otra opción es por si ya tienes instalado pip:\n\n$ pip install pipenv\n\n\nComo acabamos de ver la instalación es muy sencilla, de igual manera si tienen\nalgún problema con la instalación me pueden escribir.\n\nUsando Pipenv\nPara efectos de este ejemplo vamos a generar una aplicación sencilla usando \nFlask y haremos el típico Hola Mundo, ya que este post no se trata de desarrollo\nde apps usando Flask\n\nPrimero creamos nuestro entorno virtual para aislar nuestra aplicación:\n\n$ pipenv shell\n\nCreating a virtualenv for this project…\nPipfile: /home/usuario/nombre_del_proyecto/Pipfile\nUsing /usr/bin/python3 (3.6.7) to create virtualenv…\n\n\nCon la ejecución de este comando se crea un entorno virtual si no existe, ademas\nde crear 2 archivos: Pipfile y Pipfile.lock.\n\nSi se instala en un proyecto preexistente Pipenv convierte tu archivo \nrequirements.txt en Pipfile.\n\nPara este proyecto se ha creado un entorno con una versión de python 3, si\nnecesitas instalar una versión de python 2 solo debes agregar el argumento\n--two, también funciona para python 3 el argumento --three.\n\n$ pipenv shell --two    #Genera entorno en Python2\n$ pipenv shell --three  #Genera entorno en Python3\n\n\nAhora procedemos a instalar los paquetes que necesitamos, en nuestro caso Flask,\npero supondremos que necesitamos una versión especifica para este ejemplo\nusaremos la versión 1.0, para el momento de escribir este post la versión latest\nde Flask es la 1.0.2\n\n$ pipenv install flask==1.0\n\nInstalling flask==1.0…\nAdding flask to Pipfile's [packages]…\n✔ Installation Succeeded \nPipfile.lock not found, creating…\nLocking [dev-packages] dependencies…\nLocking [packages] dependencies…\n✔ Success! \nUpdated Pipfile.lock (db0e09)!\nInstalling dependencies from Pipfile.lock (db0e09)…\n  🐍   ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ 6/6 —\n\n\nCon esto ya tendremos Flask instalado en nuestro entorno virtual, y procedemos a\nrealizar nuestro desarrollo.\n\nCrean un archivo llamado apps.py con este contenido dentro:\n\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello World!\"\n\n\nPor ultimo iniciamos nuestro servidor Flask\n\n$ FLASK_APP=apps.py flask run\n\n * Serving Flask app \"apps.py\"\n * Environment: production\n   WARNING: Do not use the development server in a production environment.\n   Use a production WSGI server instead.\n * Debug mode: off\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n\n\nCon esto tendremos nuestro server Flask corriendo nuestro archivo apps.py.\n\nConsideraciones finales\nA lo largo de este post hemos visto como el flujo de trabajo se puede optimizar\ncon el uso de esta herramienta, ya que no debemos generar los entornos virtuales\npor separado usando algo como virtualenv con el que como yo muchas personas no\nhan estado conformes, también hemos visto como instalar paquetes usando pipenv\ntan fácil como si usáramos pip, queda de parte de cada quien darle una probada a\nesta herramienta y ver si le ayuda a optimizar su flujo de desarrollo y mantener\nun poco más homogéneo los ambientes de desarrollo.\n\nSi deseas que siga publicando contenido sobre entornos virtuales, pip, o\nexplique más a fondo los ficheros Pipfileo Pipfile.lock, que otros comandos\npuede ejecutar Pipenv, solo házmelo saber en un comentario o a través de mi\ncuenta twitter @rafnixg [https://twitter.com/rafnixg]\n\nReferencias\nDocumentación Pipenv [https://pipenv-es.readthedocs.io/es/latest/]","html":"<!--kg-card-begin: markdown--><p>Cuando iniciamos en el desarrollo con Python muchas veces no nos damos cuenta del dolor de cabeza que es mantener varios proyectos con diferentes versiones de dependencias en nuestra entorno de desarrollo local, a medida que vamos evolucionando vamos adquiriendo nuevas herramientas que mejoren nuestro flujo de trabajo, como el uso de entornos virtuales o manejadores de paquetes, entre otras, Pipenv es una de estas herramientas que nos ayudan mucho a integrar y mejorar nuestros flujos en Python, tanto es así que su eslogan por así decirlo es <em>&quot;Python Development Workflow for Humans&quot;</em>.</p>\n<p>Esta herramienta básicamente nos ayuda a optimizar nuestro flujo de desarrollo unificando <em>pip</em> y <em>virtualenv</em> en una sola herramienta que funciona por linea de comandos <em>(Terminal)</em>, lo que nos daria un entorno aislado en el cual instalar nuestras dependencia y luego replicar este mismo entorno en otra maquina gracias a el archivo que se genera <strong><a href=\"https://github.com/pypa/pipfile\">Pipfile</a></strong>, que viene a ser el sustituto del archivo que genera pip  <strong>requirements.txt</strong></p>\n<h2 id=\"instalandopipenv\">Instalando Pipenv</h2>\n<p>El proceso de instalación de Pipenv es muy sencillo, en esta ocasión voy a detallar 2 formas de instalar usando lo indicado en la <a href=\"https://pipenv-es.readthedocs.io/es/latest/\">documentación oficial</a>.</p>\n<p>Si estas usando Ubuntu 16.04:</p>\n<pre><code class=\"language-bash\">$ sudo apt install software-properties-common python-software-properties\n$ sudo add-apt-repository ppa:pypa/ppa\n$ sudo apt update\n$ sudo apt install pipenv\n</code></pre>\n<p>Esta otra opción es por si ya tienes instalado pip:</p>\n<pre><code class=\"language-bash\">$ pip install pipenv\n</code></pre>\n<p>Como acabamos de ver la instalación es muy sencilla, de igual manera si tienen algún problema con la instalación me pueden escribir.</p>\n<h2 id=\"usandopipenv\">Usando Pipenv</h2>\n<p>Para efectos de este ejemplo vamos a generar una aplicación sencilla usando <code>Flask</code> y haremos el típico <em>Hola Mundo</em>, ya que este post no se trata de desarrollo de apps usando <code>Flask</code></p>\n<p>Primero creamos nuestro entorno virtual para aislar nuestra aplicación:</p>\n<pre><code class=\"language-bash\">$ pipenv shell\n\nCreating a virtualenv for this project…\nPipfile: /home/usuario/nombre_del_proyecto/Pipfile\nUsing /usr/bin/python3 (3.6.7) to create virtualenv…\n</code></pre>\n<p>Con la ejecución de este comando se crea un entorno virtual si no existe, ademas de crear 2 archivos: <code>Pipfile</code> y <code>Pipfile.lock</code>.</p>\n<p>Si se instala en un proyecto preexistente Pipenv convierte tu archivo <em>requirements.txt</em> en <em>Pipfile</em>.</p>\n<p>Para este proyecto se ha creado un entorno con una versión de python 3, si necesitas instalar una versión de python 2 solo debes agregar el argumento --two, también funciona para python 3 el argumento --three.</p>\n<pre><code class=\"language-bash\">$ pipenv shell --two    #Genera entorno en Python2\n$ pipenv shell --three  #Genera entorno en Python3\n</code></pre>\n<p>Ahora procedemos a instalar los paquetes que necesitamos, en nuestro caso Flask, pero supondremos que necesitamos una versión especifica para este ejemplo usaremos la versión 1.0, para el momento de escribir este post la versión latest de Flask es la 1.0.2</p>\n<pre><code class=\"language-bash\">$ pipenv install flask==1.0\n\nInstalling flask==1.0…\nAdding flask to Pipfile's [packages]…\n✔ Installation Succeeded \nPipfile.lock not found, creating…\nLocking [dev-packages] dependencies…\nLocking [packages] dependencies…\n✔ Success! \nUpdated Pipfile.lock (db0e09)!\nInstalling dependencies from Pipfile.lock (db0e09)…\n  🐍   ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ 6/6 —\n</code></pre>\n<p>Con esto ya tendremos Flask instalado en nuestro entorno virtual, y procedemos a realizar nuestro desarrollo.</p>\n<p>Crean un archivo llamado <code>apps.py</code> con este contenido dentro:</p>\n<pre><code class=\"language-python\">from flask import Flask\napp = Flask(__name__)\n\n@app.route(&quot;/&quot;)\ndef hello():\n    return &quot;Hello World!&quot;\n</code></pre>\n<p>Por ultimo iniciamos nuestro servidor Flask</p>\n<pre><code class=\"language-bash\">$ FLASK_APP=apps.py flask run\n\n * Serving Flask app &quot;apps.py&quot;\n * Environment: production\n   WARNING: Do not use the development server in a production environment.\n   Use a production WSGI server instead.\n * Debug mode: off\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n</code></pre>\n<p>Con esto tendremos nuestro server Flask corriendo nuestro archivo <code>apps.py</code>.</p>\n<h2 id=\"consideracionesfinales\">Consideraciones finales</h2>\n<p>A lo largo de este post hemos visto como el flujo de trabajo se puede optimizar con el uso de esta herramienta, ya que no debemos generar los entornos virtuales por separado usando algo como <code>virtualenv</code> con el que como yo muchas personas no han estado conformes, también hemos visto como instalar paquetes usando pipenv tan fácil como si usáramos <code>pip</code>, queda de parte de cada quien darle una probada a esta herramienta y ver si le ayuda a optimizar su flujo de desarrollo y mantener un poco más homogéneo los ambientes de desarrollo.</p>\n<p>Si deseas que siga publicando contenido sobre entornos virtuales, pip, o explique más a fondo los ficheros <code>Pipfile</code>o <code>Pipfile.lock</code>, que otros comandos puede ejecutar Pipenv, solo házmelo saber en un comentario o a través de mi cuenta twitter <a href=\"https://twitter.com/rafnixg\">@rafnixg</a></p>\n<p><strong>Referencias</strong><br>\n<a href=\"https://pipenv-es.readthedocs.io/es/latest/\">Documentación Pipenv</a></p>\n<!--kg-card-end: markdown-->","url":"http://localhost:2368/entornos-virtuales-en-python-usando-pipenv/","canonical_url":null,"uuid":"7cebd5af-d7b3-4d7b-a0e6-caec08adad81","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5ef6d2f82f13451cfdfd928f","reading_time":3}},{"node":{"id":"Ghost__Post__5f330dd9c6b819e6351398d5","title":"Deploy usando GIT-FTP","slug":"deploy-usando-git-ftp","featured":false,"feature_image":"https://images.unsplash.com/photo-1554098415-788601c80aef?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ","excerpt":"Es muy común que cuando nos estamos iniciando en el mundo del desarrollo web y\nno tenemos dinero para costearnos un buen servicio, optemos por comprar espacio\nen un ‘Shared host’ o utilizar un hosting gratuito que básicamente funcional\nigual.\n\nIntroducción\n\nCuando queremos desplegar nuestros proyectos webs en estos servicios de bajo\ncosto o gratuitos, nos encontramos con una limitante de que no tenemos acceso\npor SSH, sino que nos colocan a disposición una cuenta FTP.\n\nPara muchos que no han usa","custom_excerpt":null,"visibility":"public","created_at_pretty":"22 July, 2020","published_at_pretty":"26 June, 2018","updated_at_pretty":"22 July, 2020","created_at":"2020-07-22T13:55:25.000-05:00","published_at":"2018-06-26T13:57:00.000-05:00","updated_at":"2020-07-22T17:04:37.000-05:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Rafnix Guzmán","slug":"rafnix","bio":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Rafnix Guzmán","slug":"rafnix","bio":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"git","slug":"git","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"git","slug":"git","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Es muy común que cuando nos estamos iniciando en el mundo del desarrollo web y\nno tenemos dinero para costearnos un buen servicio, optemos por comprar espacio\nen un ‘Shared host’ o utilizar un hosting gratuito que básicamente funcional\nigual.\n\nIntroducción\n\nCuando queremos desplegar nuestros proyectos webs en estos servicios de bajo\ncosto o gratuitos, nos encontramos con una limitante de que no tenemos acceso\npor SSH, sino que nos colocan a disposición una cuenta FTP.\n\nPara muchos que no han usado o trabajado con el control de versiones esto no es\nun problema, si has usado git o no sabes que es te invito a ver el curso de \nGIT/GitHub [https://platzi.com/cursos/git-github/] de Platzi\n[https://medium.com/u/5281ef6d82cd] para que entiendas porque debes usarlo.\n\nPero si queremos mantener un buen flujo de trabajo y llevar el seguimiento de\nnuestro proyecto usar git es tarea fundamental y a la hora del despliegue es una\nherramienta que nos facilita la vida, a diferencia de FTP que hace el proceso de\ndespliegue muy tedioso y con mucha perdida de tiempo, ya que debemos saber que\narchivos fueron modificados para subir al servidor.\n\nGit-FTP\n\nEsa herramienta nos viene a solucionar ese problema de no subir todos los\narchivos o seleccionar de forma manual los archivos que deseamos subir al\nservidor, sino que el se encarga de revisar que archivos fueron modificados\ndesde la ultima actualización y solo sube estos archivos.\n\nQue belleza y que hermosura fue lo que yo pensé cuando di con esta herramienta,\nya que obviamente hace que nuestro flujo de trabajo sea mas optimo que usando\nsolamente FTP, pero no todo es así de bello existe una limitación al usar este\ncliente FTP y es que las modificaciones hechas directamente sobre el servidor no\nserán vista desde nuestra área local, por lo que aconsejo mantener esto en\ncuenta.\n\nInstalacion de Git-FTP\n\nLa instalación es muy sencilla para los que usamos GNU/Linux yo en especial uso\nDebian es muy sencillo de instalar usando la terminal, para los que usen otro\nsistema operativo acá les dejo el Manual de Instalación Oficial\n[https://github.com/git-ftp/git-ftp/blob/master/INSTALL.md] donde encontraran la\ninstalación para los siguientes Sistemas operativos:\n\n * Linux/Unix usando make\n * Debian, Ubuntu y otros usando apt\n * ArchLinux\n * Mac OS X\n * Windows\n\nPara los que usamos Debian o Ubuntu solo debemos teclear esto en la terminal\n\nsudo apt-get install git-ftp\n\nCon esto ya tendríamos Git-FTP instalado\n\nConfiguración\n\nLa configuración es muy sencilla desde nuestro terminal usamos los siguientes\ncomandos:\n\ngit config git-ftp.url ftp.example.net\n\ngit config git-ftp.user ftp-user\n\ngit config git-ftp.password secr3t\n\nYa con esto tendríamos configurada la conexión a nuestro servidor por FTP, solo\nresta ubicarnos en la carpeta de nuestro proyecto y dependiendo las siguientes 2\nopciones ejecutar el comando que sea conveniente:\n\n * Subir todos los archivos (inicializacion)\n   git ftp init\n * Indicar que los archivos ya se encuentran en el servidor.\n   git ftp catchup\n\nHaciendo Deploy\n\nPara hacer deploy seguimos nuestro flujo de trabajo normal usando git, en el\nmomento que necesitemos subir los archivos modificados al servidor solo debemos\nejecutar este comando en la terminal:\n\ngit ftp push\n\nCon esto ya tendremos nuestros archivos en el servidor.\n\nRecomendación\n\n> Para los que no usan aún git visitar el curso de Git/GitHub que hay en la\nplataforma Platzi [https://medium.com/u/5281ef6d82cd].\n> Mantener siempre el mismo flujo de trabajo y no modificar archivos directamente\nal servidor.\n> Leer la documentación Oficial de Git-FTP - Pagina Oficial de Git-FTP\n[https://git-ftp.github.io/]","html":"<p>Es muy común que cuando nos estamos iniciando en el mundo del desarrollo web y no tenemos dinero para costearnos un buen servicio, optemos por comprar espacio en un ‘Shared host’ o utilizar un hosting gratuito que básicamente funcional igual.</p><p><strong>Introducción</strong></p><p>Cuando queremos desplegar nuestros proyectos webs en estos servicios de bajo costo o gratuitos, nos encontramos con una limitante de que no tenemos acceso por SSH, sino que nos colocan a disposición una cuenta FTP.</p><p>Para muchos que no han usado o trabajado con el control de versiones esto no es un problema, si has usado git o no sabes que es te invito a ver el curso de <a href=\"https://platzi.com/cursos/git-github/\" rel=\"nofollow noopener noopener\">GIT/GitHub</a> de <a href=\"https://medium.com/u/5281ef6d82cd\">Platzi</a> para que entiendas porque debes usarlo.</p><p>Pero si queremos mantener un buen flujo de trabajo y llevar el seguimiento de nuestro proyecto usar git es tarea fundamental y a la hora del despliegue es una herramienta que nos facilita la vida, a diferencia de FTP que hace el proceso de despliegue muy tedioso y con mucha perdida de tiempo, ya que debemos saber que archivos fueron modificados para subir al servidor.</p><p><strong>Git-FTP</strong></p><p>Esa herramienta nos viene a solucionar ese problema de no subir todos los archivos o seleccionar de forma manual los archivos que deseamos subir al servidor, sino que el se encarga de revisar que archivos fueron modificados desde la ultima actualización y solo sube estos archivos.</p><p>Que belleza y que hermosura fue lo que yo pensé cuando di con esta herramienta, ya que obviamente hace que nuestro flujo de trabajo sea mas optimo que usando solamente FTP, pero no todo es así de bello existe una limitación al usar este cliente FTP y es que las modificaciones hechas directamente sobre el servidor no serán vista desde nuestra área local, por lo que aconsejo mantener esto en cuenta.</p><p><strong>Instalacion de Git-FTP</strong></p><p>La instalación es muy sencilla para los que usamos GNU/Linux yo en especial uso Debian es muy sencillo de instalar usando la terminal, para los que usen otro sistema operativo acá les dejo el <a href=\"https://github.com/git-ftp/git-ftp/blob/master/INSTALL.md\" rel=\"nofollow noopener noopener\">Manual de Instalación Oficial</a> donde encontraran la instalación para los siguientes Sistemas operativos:</p><ul><li>Linux/Unix usando make</li><li>Debian, Ubuntu y otros usando apt</li><li>ArchLinux</li><li>Mac OS X</li><li>Windows</li></ul><p>Para los que usamos Debian o Ubuntu solo debemos teclear esto en la terminal</p><p><code>sudo apt-get install git-ftp</code></p><p>Con esto ya tendríamos Git-FTP instalado</p><p><strong>Configuración</strong></p><p>La configuración es muy sencilla desde nuestro terminal usamos los siguientes comandos:</p><p><code>git config git-ftp.url ftp.example.net</code></p><p><code>git config git-ftp.user ftp-user</code></p><p><code>git config git-ftp.password secr3t</code></p><p>Ya con esto tendríamos configurada la conexión a nuestro servidor por FTP, solo resta ubicarnos en la carpeta de nuestro proyecto y dependiendo las siguientes 2 opciones ejecutar el comando que sea conveniente:</p><ul><li>Subir todos los archivos (inicializacion)<br> <code>git ftp init</code></li><li>Indicar que los archivos ya se encuentran en el servidor.<br> <code>git ftp catchup</code></li></ul><p><strong>Haciendo Deploy</strong></p><p>Para hacer deploy seguimos nuestro flujo de trabajo normal usando git, en el momento que necesitemos subir los archivos modificados al servidor solo debemos ejecutar este comando en la terminal:</p><p><code>git ftp push</code></p><p>Con esto ya tendremos nuestros archivos en el servidor.</p><p><strong>Recomendación</strong></p><blockquote>Para los que no usan aún git visitar el curso de Git/GitHub que hay en la plataforma <a href=\"https://medium.com/u/5281ef6d82cd\">Platzi</a>.</blockquote><blockquote>Mantener siempre el mismo flujo de trabajo y no modificar archivos directamente al servidor.</blockquote><blockquote>Leer la documentación Oficial de Git-FTP - <a href=\"https://git-ftp.github.io/\" rel=\"nofollow noopener noopener noopener\">Pagina Oficial de Git-FTP</a></blockquote>","url":"http://localhost:2368/deploy-usando-git-ftp/","canonical_url":null,"uuid":"2a188aa8-4874-4c08-ac0a-4ca80e8c9a79","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f188b9d2f13451cfdfd92f2","reading_time":2}},{"node":{"id":"Ghost__Post__5f330dd9c6b819e6351398d4","title":"Ejecutar Código JavaScript en Sublime Text","slug":"ejecutar-codigo-javascript-en-sublime-text","featured":false,"feature_image":"https://images.unsplash.com/photo-1572621403925-33e05716ad8d?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=2000&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ","excerpt":"Cuando estamos iniciando en el desarrollo con JavaScript uno de los flujos de\ntrabajos menos óptimos para no decir los mas fastidiosos, son tener que escribir\nel código en nuestro editor de código favorito y tener que ir a la consola del\nexplorador a probarlo.\n\nPara resolver este problema existen muchos camino, el que yo propongo aquí es el\nque mas se adapto a mis necesidades y espero que pueda ayudar en las suyas, para\ntodos esos que usan Sublime Text y mantiene este flujo de trabajo de crear\nc","custom_excerpt":null,"visibility":"public","created_at_pretty":"22 July, 2020","published_at_pretty":"28 June, 2017","updated_at_pretty":"22 July, 2020","created_at":"2020-07-22T13:47:47.000-05:00","published_at":"2017-06-28T13:48:00.000-05:00","updated_at":"2020-07-22T17:01:37.000-05:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Rafnix Guzmán","slug":"rafnix","bio":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Rafnix Guzmán","slug":"rafnix","bio":null,"profile_image":"//www.gravatar.com/avatar/5fb1357b705cbfd44fbbe63c7395c57c?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":{"name":"javascript","slug":"javascript","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"javascript","slug":"javascript","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"Cuando estamos iniciando en el desarrollo con JavaScript uno de los flujos de\ntrabajos menos óptimos para no decir los mas fastidiosos, son tener que escribir\nel código en nuestro editor de código favorito y tener que ir a la consola del\nexplorador a probarlo.\n\nPara resolver este problema existen muchos camino, el que yo propongo aquí es el\nque mas se adapto a mis necesidades y espero que pueda ayudar en las suyas, para\ntodos esos que usan Sublime Text y mantiene este flujo de trabajo de crear\ncódigo en sublime y luego pasarlo a un explorador y depurar en la consola del\nexplorador doy este pequeño pero para mi poderoso tip.\n\nInicialmente debemos tener instalado Sublime Text, es muy sencillo de instalar y\nen su sitio web existe mucha documentación al respecto, y lo segundo que\ntendremos que tener instalado es Node.js,\n\nSi aun no tienes instalado Node.js acá te dejo la documentación oficial donde\nencontrás la guiá de como instalarlo en cualquier sistema operativo que uses, \nManual de Instalación [https://nodejs.org/es/download/package-manager/]\n\nConfigurando Sublime\nLuego de tener Sublime Text y Node.js instalados y funcionando, vamos a proceder\na hacer una pequeña configuración en sublime Text, para esto debemos ingresar en \n“Tools > Build System > New Build System”, se abrirá un documento nuevo con el\nsiguiente contenido:\n\n> {\n“cmd”: [“make”]\n}\nEste contenido debe ser sustituido por el siguiente:\n\n> {\n“cmd”: [“node”, “$file”],\n“selector”: “source.js”\n}\nHecho esto procedemos a guardar el archivo en la ruta sugerida por Sublime Text,\npara poder probar que esta funcionando solo debemos crear un nuevo archivo JS\ncon el código JavaScript que deseen, recomiendo solo a modo de prueba el\nsiguiente:\n\n> console.log(“JavaScript funcionando desde Sublime Text”)\nGuardan el archivo nuevo con el nombre que deseen en mi caso “prueba.js” y para\npoder ejecutarlo deben ir a “Tools > Build” o ejecutando la siguiente\ncombinación de teclas “Control + B”.\n\nRecomendaciones\nPara los que se están iniciando en el mundo de JavaScript los recomiendo leer un\npoco sobre Node.js y lo potente que puede llegar a ser, ya que en este post no\nse aprecia la potencia de este.\n\nInstalar Snippets y verificadores de código para Sublime Text, para aumentar su\nproductividad y saber donde puedan tener posibles errores.","html":"<p>Cuando estamos iniciando en el desarrollo con JavaScript uno de los flujos de trabajos menos óptimos para no decir los mas fastidiosos, son tener que escribir el código en nuestro editor de código favorito y tener que ir a la consola del explorador a probarlo.</p><p>Para resolver este problema existen muchos camino, el que yo propongo aquí es el que mas se adapto a mis necesidades y espero que pueda ayudar en las suyas, para todos esos que usan <em>Sublime Text</em> y mantiene este flujo de trabajo de crear código en sublime y luego pasarlo a un explorador y depurar en la consola del explorador doy este pequeño pero para mi poderoso tip.</p><p>Inicialmente debemos tener instalado <em>Sublime Text</em>, es muy sencillo de instalar y en su sitio web existe mucha documentación al respecto, y lo segundo que tendremos que tener instalado es <em>Node.js</em>,</p><p>Si aun no tienes instalado <em>Node.js</em> acá te dejo la documentación oficial donde encontrás la guiá de como instalarlo en cualquier sistema operativo que uses, <a href=\"https://nodejs.org/es/download/package-manager/\" rel=\"noopener\">Manual de Instalación</a></p><h4 id=\"configurando-sublime\">Configurando Sublime</h4><p>Luego de tener Sublime Text y Node.js instalados y funcionando, vamos a proceder a hacer una pequeña configuración en sublime Text, para esto debemos ingresar en <strong>“Tools &gt; Build System &gt; New Build System”</strong>, se abrirá un documento nuevo con el siguiente contenido:</p><blockquote>{<br> “cmd”: [“make”]<br>}</blockquote><p>Este contenido debe ser sustituido por el siguiente:</p><blockquote>{<br> “cmd”: [“node”, “$file”],<br> “selector”: “source.js”<br>}</blockquote><p>Hecho esto procedemos a guardar el archivo en la ruta sugerida por Sublime Text, para poder probar que esta funcionando solo debemos crear un nuevo archivo JS con el código JavaScript que deseen, recomiendo solo a modo de prueba el siguiente:</p><blockquote>console.log(“JavaScript funcionando desde Sublime Text”)</blockquote><p>Guardan el archivo nuevo con el nombre que deseen en mi caso <strong>“prueba.js”</strong> y para poder ejecutarlo deben ir a <strong>“Tools &gt; Build”</strong> o ejecutando la siguiente combinación de teclas <strong>“Control + B”</strong>.</p><h4 id=\"recomendaciones\">Recomendaciones</h4><p>Para los que se están iniciando en el mundo de JavaScript los recomiendo leer un poco sobre Node.js y lo potente que puede llegar a ser, ya que en este post no se aprecia la potencia de este.</p><p>Instalar Snippets y verificadores de código para Sublime Text, para aumentar su productividad y saber donde puedan tener posibles errores.</p>","url":"http://localhost:2368/ejecutar-codigo-javascript-en-sublime-text/","canonical_url":null,"uuid":"71451fbb-0071-438c-bd0a-49f2b67293e7","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"5f1889d32f13451cfdfd92e4","reading_time":2}}]}},"pageContext":{"slug":"rafnix","limit":12,"skip":0,"numberOfPages":1,"humanPageNumber":1,"prevPageNumber":null,"nextPageNumber":null,"previousPagePath":null,"nextPagePath":null}},"staticQueryHashes":["176528973","2358152166","2561578252","2731221146","4145280475"]}